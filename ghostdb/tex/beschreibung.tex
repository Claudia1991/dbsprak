\chapter{Einführung}

In der Vorlesung Techniken und Konzepte zum Schutz der Privatsphäre haben wir uns mit verschiedenen Techniken und Verfahren zur Anonymisierung von sensitiven Daten und deren Sicherung beschäftigt. Eine hierbei behandelte Idee ist die sogenannte ``GhostDB''.\footnote{GhostDB: Hiding Data from Prying Eyes} \footnote{GhostDB: Querying Visible and Hidden Data Without Leaks} \footnote{Vortrag: GhostDB: Hiding Data from Prying Eyes (Technology)}

Das gesamte System, welches die ``GhostDB'' umfasst basiert auf verschiedenen Komponenten und ist sehr umfangreich. Wir beschränken uns daher in dieser Arbeit auf das sogenannte Post- und Prefiltering. Beide Verfahren werden bei der Abarbeitung von Anfragen eingesetzt um diese möglichst effizient und schnell zu beantworten. Wir werden diese Techniken kurz vorstellen und anhand eines kleinen Beispieles ihre Funktionsweise erklären.

Im folgenden wollen wir eine kurze Einführung in unsere Datenbasis geben um später auf diese zurückgreifen zu können.	
	
\chapter{Datenbasis}

In den Papern zu diesem Thema wurden meist Beispiele aus dem medizinischen Bereich gewählt mit Ärzten, Patienten, Untersuchungen etc. Wir haben uns nach reiflicher Überlegung für den Bereich des Flugverkehrs entschieden. In diesem Feld existieren viele verschiedene Daten, die je nach Angreifermodell und Nutzer zu schützen sind. Eine Fluggesellschaft ist zum Beispiel daran interessiert, welche Reisende ihr Kontigent an Gepäckstückem beziehungsweise mitzuführendes Gepäckgewicht überschreiten, um ihnen beim nächsten Flug ein teureres Ticket verkaufen zu können. Auf die Spitze getrieben möchte ein Terrorist in Erfahrung bringen, welcher Pilot ein bestimmtes Flugzeug fliegt und ob bestimmte Personen, wie zum Beispiel Polizisten, im Flugzeug sitzen.

Die Herausforderung bestand erst einmal in der Suche nach dem aus unserer Sicht besten Datenmodell für dieses Szenario, welches nicht zu komplex ausfällt um den Rahmen dieser Arbeit nicht zu sprengen. Ein weiterer Augenmerk lag darauf, so wenig Daten wie möglich in den ``sicheren'' Bereich der späteren ``GhostDB'' zu verlagern ohne die Sicherheit der Daten zu gefährden.\textbf{(TODO: noch mal durchlesen, gefällt mir noch nicht von der Formulierung)}.

\begin{figure}[htb]
  \centering%
  \includegraphics[width=0.8\linewidth]{img/Datenmodell.pdf}%
  \caption{Datenmodell}
  \label{fig:Datenmodell}
\end{figure}%

\chapter{Datenstrukturen TODO: bessere Erklärung}

Um im Laufe der Erklärungen zu den verschiedenen Methoden einen Ablaufplan für eine Anfrage auf der ``GhostDB'' zu erstellen werden verschiedenen Datenstrukturen benötigt. Einige von ihnen wollen wir kurz vorstellen.

\section{Subtree Key Table}

Eine dieser Strukturen ist der ``Subtree Key Table''. Hierbei enthält die Wurzeltabelle  alle ID's der nachfolgenden Tabellen, ??? \textbf{TODO: SKT und CI beschreiben}

\section{Climbing Index}

Eine weitere Struktur ist der ``Climbing Index''......

\chapter{Warum Filter ?}

Das System ``GhostDB'' hat das Problem, dass alle Berechnungen die Bezug auf die unsichtbaren Daten auf dem ``SmartUSB''-Stick nehmen in diesem berechnet werden müssen. Da der Speicher für die Ausführung auf diesem Gerät aber begrenzt ist, entsteht hier ein Ressourcenproblem, da alle Daten in den Speicher geladen werden müssen und weiterhin in diesem auch Platz für das Ergebnis vorhanden sein muss. Die Autoren der Paper haben daher eine Möglichkeit gesucht die Menge an Informationen, die in den Speicher geladen werden müssen, um eine Antwort auf die gestellte Anfrage zu erhalten, zu verringern. Das Ergebnis waren die Post-, Pre- und Crossfilter. In dieser Arbeit werden wir nur auf die ersten beiden eingehen.

\section{Prefiltering}

Die Idee beim Prefiltering ist, dass alle Selektionen zuerst ausgeführt werden um die gesamte Datenmenge die bei Joins und Mergeoperationen verwendet werden so gering wie möglich zu halten. Weiterhin wird versucht so viele Selektionen wie möglich auf dem unsicheren Bereich auszuführen, da die Ressourcen hier nicht so beschränkt sind, wie im sicheren Bereich. Selektionen auf Daten die den sicheren Teil der ``GhostDB'' betreffen können allerdings auch nur in diesem ausgeführt werden. Für die Selektionen werden nach Möglichkeit ``Climbing'' Indizes verwendet. Die danach folgenden Joins werden dann im sicheren Bereich ausgeführt, hierbei wird dann meist ein ``Subtree Key Table'' verwendet.

\section{Postfiltering}

Beim Postfiltering wird ein anderes Verfahren verwendet. Es wird hier zuerst der Join auf dem sicheren Teil der ``GhostDB'' ausgeführt. Im folgenden werden die möglichen Selektionen des unsicheren Bereiches zu den erzeugten Ergebnissen hinzugefügt. Dies geschieht entweder durch das Erzeugen eines Blommfilters aus diesen Daten, der dann für die Filterung der bisherigen Ergebnisse benutzt wird oder genau umgekehrt. Im umgedrehten Fall wird der Bloomfilter aus den vorhandenen Resultaten gebildet und die Daten der Selektion werden mit diesem gefiltert. Die übrig gebliebenen Daten werden dann weiterverabeitet. \textbf{TODO: hier könnte noch mehr kommen}

Cross-Filtering kann teilweise bessere Ergebnisse erzielen. Es wird versucht die Kardinalität von Zwischenergebnissen des unsicheren Geräts so klein wie möglich zu halten, indem ``Filter'' oder ``Merge''-Operationen mit sicheren Daten so früh wie möglich durchgeführt werden.

\chapter{Anwendung}

Die folgenden Beispiele zum Pre- und Postfiltering basieren auf der oben schon vorgestellten Datenbasis und der folgenden Anfrage:


\begin{Verbatim}[commandchars=\\\{\}]
SELECT R.ReisenderID, R.Vorname, R.Name, R.Staatsbuergerschaft
FROM Buchungen B, Gepaeck G, Fluege F, Reisende R, Piloten P
WHERE R.Geschlecht='M' AND P.Geburtsdatum<1956-08-01 AND G.Gewicht>20
    AND B.Flug=F.FlugID AND B.Reisender=R.ReisenderID
    AND G.Flug=F.FlugID AND G.Reisender=R.ReisenderID
    AND F.Pilot=P.PilotID
\end{Verbatim}

Die genauen Funktionsaufrufe, die in den Papern erklärt sind, sind unter dem Abschnitt Query Execution Plan zu finden. Die Funktionsweise der einzelnen Funktionen (bis auf MJoin, dass leider nie deklariert oder definiert wurde) kann in den entsprechenden Papern nachgelesen werden.

\section{Prefiltering}

Beim Prefiltering-Verfahren kommt es wie oben schon erwähnt darauf an die Selektionen der Anfrage (Query) \textbf{TODO: Was ist besser Query und Anfrage verwenden oder jeweils nur eines der beiden Wörter???} so früh wie möglich auszuführen um weniger Daten für die weitere Verarbeitung zu haben. In unserem Beispiel kommen drei Selektionen vor. Diese sind die Auswahl des Geschlechts des Reisenden, das Geburtsdatum des Piloten und das Gewicht des Gepäcks. In der Regel ist eine Selektion immer dann am schnellsten, wenn Sie einen Bereich betrifft der nicht versteckt ist, da hier alle Ressourcen der unsicheren Plattform benutzt werden können. Diese sind meist um ein vielfaches höher als die des ``SmartUSB''-Sticks. Aus diesem Grund beginnen wir mit der Auswahl des Gewichts. Wir wollen alle GepaeckIds herausfiltern für die gilt, dass das ihnen zugeordnetes Gewicht größer als 20 Kilogramm ist. Dies wären die folgenden IDs (siehe Tabelle \ref{tab:Gepaeck}):  G06, G12, G13, G16, G18, G19, G20, G22, G23. \textbf{TODO: hier sollte irgendwie erwähnt werden das die GIds zur sicheren Plattform übertragen werden}

Der nächste naheliegende Schritt wäre die Auswahl des Geschlechts der Reisenden, da diese Eigenschaft nicht versteckt ist, aus später noch zu erläuternden Gründen machen wir dies aber erst einmal nicht.

Es bleibt demzufolge nur noch die Selektion auf den Piloten. Diese Eigenschaft ist versteckt und muss daher auf der sicheren Plattform ausgeführt werden. Als Ergebnis würden wir alle PilotenIds erhalten, deren Geburtstag vor dem 01.08.1956 liegt. Mit dieser Information kann aber nur schlecht weitergearbeitet werden, da wir bis jetzt nur GepaeckIds vorliegen. Aus diesem Grund wird ein ``ClimbingIndex'' auf dem Attribut Geburtsdatum verwendet (siehe Tabelle \ref{tab:ClimbingIndexPilotenGeburtsdatum}) und auf diesem wird dann die Selektion ausgeführt. Als Ergebnis werden folgende GepaeckIds im sicheren Bereich vorgehalten: G07, G18, G19, G20, G25.

Die nun vorhandenen IDs können mittels der Schnittmenge verringert werden um den Aufwand für den nachfolgenden Join \textbf{TODO: darf man hier Join erwähnen oder sollte es SJoin heißen} zu verringern. Als Ergebnis bekommt man: G18, G19, G20.

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]%
  \centering%
  \frame{\includegraphics[width=1\linewidth]{img/Pre1}}
  \caption{Teilergebnis Pre-Filtering 1}%
  \label{fig:pre1}%
\end{figure}%

Im Nachfolgenden müssen alle ``Statements'' in der ``WHERE-Clause'' erfüllt werden. Dies geschieht unter zu Hilfenahme von Semi-Joins und diese werden wiederum durch ``Subtree Key Tables''(SKT) unterstützt. Die ``Where Clause'', die wir berechnen wollen ist folgende: G.Reisender=R.ReisenderID. Im SKT für Gepaeck (Tabelle \ref{tab:SKTGepaeck}) werden nun die ReisendenIDs zu den entsprechenden GepaeckIDs herausgesucht, dies geschieht mittels SJoin.\textbf{TODO: kann man das so schreiben ??}

Da wir nun ReisendeIDs haben kann die nächste Bedingung in Angriff genommen werden: B.Reisender=R.ReisenderID. Hierfür werden ReisendeIDs auf Basis der BuchungsIDs benötigt. Die Selektion mittels GepäckIDs entfällt da diese keine direkte Verbindung zu den Buchungen haben. Da wir schon die Piloten vorhin als selektives Mittel verwendet haben tun wir dies diesmal auch wieder mittels eines ``Climbing Index'' auf den BuchungsIDs. Da der ``Climbing Index'' als Ergebnis eine Liste von Listen liefert, wir für den SKT aber nur eine Liste verwenden können, müssen wir die erhaltenen Listen in der Liste mittels Vereinigung zusammenführen. Als Ergebnis würden wir folgendes erhalten: B08, B11, B18, B19, B20, B21.

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Pre2.pdf}
  \caption{Teilergebnis Pre-Filtering 2}
  \label{fig:pre2}
\end{figure}

Die so erhaltenen BuchungsIDs werden analog zu den GepaeckIDs im vorherigen Schritt benutzt um ReisendeIDs zu berechnen. Um beide Bedingungen zu erfüllen muss nun noch der Durchschnitt der beiden ReisendenIDs durchgeführt werden. Damit wären beide Bedingungen erfüllt. Mit diesem Ergebnis kann dann weiter gearbeitet werden.

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Pre3.pdf}
  \caption{Teilergebnis Pre-Filtering 3}
  \label{fig:pre3}
\end{figure}

Auf dieser entstandenen Datenbasis wird nun ein Bloomfilter gebaut, der für die noch nicht angewandte Selektion verwendet wird. Die fehlende Selektion ist diese: R.Geschlecht='M'. Die Selektion wird erst jetzt angewandt, da sie sonst vorher in den beiden Joins die zu bearbeitenden Datenmengen erhöht hätte. Durch den späteren Einsatz können die Datenmengen geringer gehalten werden und der Rechenaufwand ist somit geringer.

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Pre4.pdf}
  \caption{Teilergebnis Pre-Filtering 4}
  \label{fig:pre4}
\end{figure}

Als Abschluss müssen nur noch die entsprechenden Projektionen angewendet werden. Dies geschieht mittels eines MJoins. Dieser benötigt aber nochmals alle ReisendenIDs mit der Eigenschaft das das Geschlecht männlich ist. Bei dieser Anfrage werden aber nicht nur die ReisendenIDs benötigt, sondern auch die Attribute für Vorname und Name. Als Ergebnis kann dann folgendes ausgegeben werden: \{$\langle$R04,Doru,Davidovici,Romänisch$\rangle$\}.

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Pre5.pdf}
  \caption{Teilergebnis Pre-Filtering 5}
  \label{fig:pre5}
\end{figure}

Fügt man die einzelnen Schritte zusammen entsteht folgender Ausführungsplan für das Prefiltering:

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Pre-Filtering.pdf}
  \caption{Pre-Filtering QEP}
  \label{fig:pre}
\end{figure}

Die einzelnen ``Methoden'' die zur Berechnung verwendet wurden kann man sich unter der Rubrik Query Excecution Plans noch einmal genauer ansehen. Auf den ersten Blick scheint die Lösung des Prefiltering optimal zu sein, da man schon im Vorfeld viele Daten \textbf{TODO: ist Daten das Richtige Wort ???} aus der Berechnung der Joins herausnehmen kann und somit den Aufwand verringert.

Das Problem an dieser Strategie ist allerdings, dass bei zu geringer Selektivität der unsicheren ``Selektionen'' zu wenige Tupel im Vorfeld aussortiert werden und somit ein großer Vorteil des Prefilterings verschwindet. Eine andere Alternative, die dem eben angesprochenen Effekt nicht so stark unterliegt ist das Postfiltering.

\section{Postfiltering}

Beim Postfiltering werden zuerst alle Selektionen ausgeführt und per Join zusammengefasst, die auf den sicheren Bereich zugreifen. Erst danach werden mittels ``Fuzzy filtering''\footnote{GhostDB: Hiding Data from Prying Eyes(Technology) Vortrag} die Selektionen des unsicheren Bereiches hinzugefügt.

Für unser Beispiel heißt dies, dass zuerst die Selektion auf dem Geburtsdatum des Piloten ausgeführt wird. Da wir mit der PilotID aber nicht ohne Weiteres weiterarbeiten können, verwenden wir hierfür den ``Climbing Index'' auf der GepaeckID und führen auf diesem Ergebnis eine Vereinigung aus, da wir nur eine Liste von GepaeckIDs gebrauchen können.

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Post1.pdf}
  \caption{Teilergebnis Post-Filtering 1}
  \label{fig:post1}
\end{figure}

Diese Selektion ist in unserem Beispiel die Einzige die auf den unsicheren Bereich zugreift, nach dem Verfahren des Postfilterings werden diese IDs nun für einen Join benutzt. Als Ergebnis brauchen wir wiederum ReisendeIDs, da diese für die spätere Projektion notwendig sind. Um diese IDs zu erhalten bedienen wir uns wieder dem ``Subtree Key Table'' und Filtern uns somit alle ReisendeIds heraus. Bei den Selektionen aus dem unsicheren Berich erhalten wir aber GepaeckIds, daher gibt uns der Join auf unsere Anforderung hin eine Menge von Tupeln aus GepaeckID und dazu passender ReisenderID heraus.

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Post2.pdf}
  \caption{Teilergebnis Post-Filtering 2}
  \label{fig:post2}
\end{figure}

Im nächsten Schritt kann nun die Selektion auf dem Gepäck, welches ein Gewicht größer als 20 Kilogramm hat geschehen. Wie oben schon erwähnt wird hierfür das ``Fuzzy Filtering'' benutzt. In unserem Fall ist es so definiert, das ein Bloomfilter über eine bestimmte Menge von Daten generiert wird und dieser Filter dann auf eine andere Menge angewendet wird. Man könnte diesen Filter eventuell auf das Ergebnis des Joins beziehen, da diese Ergebnisse aber im sicheren Bereich sind würden wir hier nur unnötig Ressourcen verbrauchen. Eine bessere Lösung ist es den Bloomfilter auf der Selektion der Daten des unsicheren Bereiches zu generieren, da hier mehr Resosurcen zur Verfügung stehen.

Es wird also ein Bloomfilter auf dem Ergebnis von G.Gewicht>20 gebildet und auf folgende Daten des Joins angewendet:\{$\langle$G07,R11$\rangle$, $\langle$G18,R07$\rangle$, $\langle$G19,R04$\rangle$, $\langle$G20,R04$\rangle$, $\langle$G22,R02$\rangle$, $\langle$G23,R01$\rangle$\}.

Hierbei ist zu beachten das nur die GepaeckIDs des Ergebnisses betrachtet werden, da nur diese im Bloomfilter vorkommen. Auf der Ausgabe des Bloomfilters wird nachfolgend noch eine Projektion auf die ReisendeIDs vorgenommen, da wir die Tupel aus GepaeckID und ReisendeID nicht mehr für die nächsten Schritte benötigen. Das Ergebnis sind folgende ReisendeIDs: {R07, R04, R04, R02, R01}

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Post3.pdf}
  \caption{Teilergebnis Post-Filtering 3}
  \label{fig:post3}
\end{figure}

Als nächster logischer Schritt würde die Selektion auf dem Geschlecht folgen, da aber durch die ``Where-Clause'' B.Reisender=R.ReisenderID ebenfalls ReisendeIds entstehen, die verglichen werden müssen, wird dieser Schritt vorgezogen, da andernfalls die Selektion ein zweites Mal erfolgen müsste. Diesen Mehraufwand wollen wir uns ersparen. Um die entsprechende ``Where-Clause'' zu erfüllen, benötigen wir BuchungsIDs, die wir dann in entsprechende ReisendeIDs umwandeln können. Hier verwenden wir das gleiche Schema wie im Prefiltering. Mittels der Selektion auf dem Geburtsdatum des Piloten erhalten wir durch den ``Climbing Index'' eine Liste von Listen mit BuchungsIds. Diese muss durch eine Vereinigung zu einer Liste zusammengeführt werden.

Im folgenden wird ein SemiJoin angewendet, der unter Zuhilfenahme eines ``Subtree Key Tables'' uns die entsprechenden ReisendeIDs ausgibt, die wir dann weiterverwenden. Als Ergebnis werden folgende Ids geliefert: {R07, R03, R13, R05, R04, R11}

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Post4.pdf}
  \caption{Teilergebnis Post-Filtering 4}
  \label{fig:post4}
\end{figure}

Die beiden Mengen von ReisendeIDs werden nun mittels Durchschnitt miteinander vereint. Aus diesem Ergebnis wird nachfolgend einen Bloomfilter gebaut. Die Ergebnisse die durch die Selektion des Geschlechtes auf die Reisenden (Reisender.Geschlecht='M') im unsicheren Bereich erhaltenen Daten werden durch diesen Filter geschickt. Die nun erhaltenen IDs werden wie im Prefiltering mittels MJoin zusammengefügt und als Ergebnis erhält man: \{$\langle$R04,Doru,Davidovici,Romänisch$\rangle$\}.

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Post5.pdf}
  \caption{Teilergebnis Post-Filtering 5}
  \label{fig:post5}
\end{figure}

Fügt man nun wie schon oben alle Teile zusammen erhält man den kompletten Ablaufplan für unsere Anfrage.

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Post-Filtering.pdf}
  \caption{Post-Filtering QEP}
  \label{fig:post}
\end{figure}
