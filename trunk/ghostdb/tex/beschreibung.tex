\chapter{Einführung}

In der Vorlesung Techniken und Konzepte zum Schutz der Privatsphäre haben wir uns mit verschiedenen Techniken und Verfahren zur Anonymisierung von sensitiven Daten und deren Sicherung beschäftigt. Eine hierbei behandelte Idee ist die sogenannte "GhostDB". \footnote{GhostDB: Hiding Data from Prying Eyes }
\footnote{GhostDB: Querying Visible and Hidden Data Without Leaks}
\footnote{Vortrag: GhostDB: Hiding Data from Prying Eyes (Technology) }

Das gesamte System, welches die "GhostDB" umfasst basiert auf verschiedenen Komponenten und ist sehr umfangreich. Wir beschränken uns daher in dieser Arbeit auf das sogenannte Post- und Prefiltering. Beide Verfahren werden bei der Abarbeitung von Anfragen eingesetzt um diese möglichst effizient und schnell zu beantworten. Wir werden diese Techniken kurz vorstellen und anhand eines kleinen Beispieles ihre Funktionsweise erklären.
Im folgenden wollen wir eine kurze Einführung in unsere Datenbasis geben um später auf diese zurückgreifen zu können.	
	
\chapter{Datenbasis}
In den Papern zu diesem Thema wurden meist Beispiele aus dem medizinischen Bereich gewählt mit Ärzten, Patienten, Untersuchen, usw. Wir haben uns nach reiflicher Überlegung für den Bereich des Flugverkehrs entschieden. In diesem Feld existieren viele verschiedene Daten, die je nach Angreifermodell und Nutzer zu schützen sind. Eine Fluggesellschaft ist z.B. daran interessiert, zu wissen welche Reisende
ihr Kontigent an Gepäckstückem bzw. mitzuführendes Gepäckgewicht überschreiten um ihnen beim nächsten Flug ein teureres Ticket zu verkaufen zu können bis hin zum Terroristen der erfahren möchte welcher Pilot ein bestimmtes Flugzeug fliegt und ob bestimmte Personen wie z.B. Polizisten im Flugzeug sitzen.
Die Herausforderung bestand erst einmal in der Suche nach dem aus unserer Sicht besten Datenmodell für dieses Szenario, welches nicht zu komplex ausfällt um den Rahmen dieser Arbeit nicht zu sprengen. Ein weiterer Augenmerk lag darauf, so wenig Daten wie möglich in den "sicheren" Bereich der späteren "GhostDB" zu verlagern ohne die Sicherheit der Daten zu gefährden.\textbf{(TODO: noch mal durchlesen, gefällt mir noch nicht von der Formulierung)
Anführungszeichen müssen ersezt werden damit diese Ordnungsgemäß angezeigt werden}. 

\begin{figure}[htb]%
  \centering%
  \includegraphics[width=0.8\linewidth]{img/Datenmodell.pdf}%
  \caption{Datenmodell}%
  \label{fig:Datenmodell}%
\end{figure}%

\chapter{Datenstrukturen TODO: bessere Erklärung}

Im Laufe der Erklärungen zu den verschiedenen Methoden einen Ablaufplan für eine Anfrage auf der "GhostDB" zu erstellen werden verschiedenen Datenstrukturen benötigt. Einige von ihnen wollen wir kurz vorstellen.
\subsection{Subtree Key Table}
Eine dieser Strukturen ist der "Subtree Key Table". Hierbei enthält die Wurzeltabelle  alle ID's der nachfolgenden Tabellen, ???
\textbf{TODO: SKT und CI beschreiben}

\subsection{Climbing Index}
Eine weitere Struktur ist der "Climbing Index"......

\chapter{Warum Filter ?}
Die "GhostDB" hat das Problem, dass alle Berechnungen die Bezug auf die unsichtbaren Daten auf dem "SmartUSB"-Stick nehmen in diesem berechnet werden müssen. Da der Speicher für die Ausführung aber begrenzt ist entsteht hier ein Geschwindigkeitsproblem, da alle Daten in den Speicher geladen werden müssen und weiterhin in diesem auch Platz für das Ergebnis vorhanden sein muss. Die Autoren der Paper haben daher eine Möglichkeit gesucht die Menge an Informationen, die in den Speicher geladen werden müssen um das Ergebnis zu erhalten zu verringern. Das Ergebnis waren die Post-, Pre- und Crossfilter.

Beim Prefiltering \textbf{???} wird versucht alle Selektionen zuerst auszuführen.
Es wird versucht so viele Selektionen wie möglich auf dem unsicheren Bereich auszuführen, da die Ressourcen hier nicht so beschränkt sind, wie im sicheren Bereich. Selektionen auf Daten des sicheren Bereiches können allerdings auch nur in diesem ausgeführt werden. Für die Selektionen werden nach Möglichkeit "Climbing" Indizes verwendet.
Die danach folgenden Joins werden dann im sicheren Bereich ausgeführt, hierbei wird dann ein "Subtree Key Table" verwendet.
\textbf{TODO: zu oft Bereich benutzt}
Beim Postfiltering wird ein anderes Verfahren verwendet. Es wird hier zuerst der Join des sicheren Bereichs ausgeführt mittels "Subtree Key Table". Im folgenden werden die möglichen Selektionen des unsicheren Bereiches durch erzeugen von Bloomfilter vermittelt.
\textbf{TODO: hier könnte noch mehr kommen}
Beim Crossfiltering wiederum werden beide Techniken miteinander kombiniert um noch bessere Ergebnisse zu erzielen.


\chapter{Anwendung}

Die folgenden Beispiel zum Pre- und Postfiltering basieren auf der oben schon vorgestellten Datenbasis und der folgenden Anfrage:


\begin{Verbatim}[commandchars=\\\{\}]
SELECT R.ReisenderID, R.Vorname, R.Name, R.Staatsbuergerschaft
FROM Buchungen B, Gepaeck G, Fluege F, Reisende R, Piloten P
WHERE R.Geschlecht='M' AND P.Geburtsdatum<1956-08-01 AND G.Gewicht>20
    AND B.Flug=F.FlugID AND B.Reisender=R.ReisenderID
    AND G.Flug=F.FlugID AND G.Reisender=R.ReisenderID
    AND F.Pilot=P.PilotID
\end{Verbatim}

Die genauen Funktionsaufrufe, die in den Papern erklärt sind, sind unter dem Abschnitt Query Execution Plan zu finden.
Die Funktionsweise der einzelnen Funktionen kann in den entsprechenden Papern nachgelesen werden. 


\subsection{Prefiltering}

Beim Prefiltering-Verfahren kommt es wie oben schon erwähnt darauf an die Selektionen der Anfrage (Query) \textbf{TODO: Was ist besser Query und Anfrage verwenden oder jeweils nur eines der beiden Wörter???} so früh wie möglich auszuführen um weniger Daten für die wietere Verarbeitung zu haben. In unserem Beispiel kommen drei Selektionen vor. Diese sind die Auswahl des Geschlechts des Reisenden, das Geburtsdatum des Piloten und das Gewicht des Gepäcks. In der Regel ist eine Selektion immer dann am schnellsten, wenn Sie einen Bereich betrifft der nicht versteckt ist, da hier alle Ressourcen der unsicheren Plattform benutzt werden kann. Diese sind meist um ein vielfaches höher als die des "SmartUSB"-Sticks. Aus diesem Grund beginnen wir mit der Auswahl des Gewichts. Wir wollen alle GepaeckIds herausfiltern für die gilt, dass das ihnen zugeordnetes Gewicht größer als 20 Kilogramm ist. Dies wären die folgenden IDs(siehe Tabelle 7.8):  G06, G12, G13, G16, G18, G19, G20, G22, G23.
\textbf{TODO: hier sollte irgendwie erwähnt werden das die GIds zur sicheren Plattform übertragen werden}
Der nächste naheliegende Schritt wäre die Auswahl des Geschlechts der Reisenden, da diese Eigenschaft nicht versteckt ist, aus später noch zu erläuternden Gründen machen wir dies aber erst einmal nicht. 
Es bleibt demzufolge nur noch die Selektion auf den Piloten. Diese Eigenschaft ist versteckt und muss daher auf der sicheren Plattform ausgeführt werden.
Als Ergebnis würden wir alle PilotenIds erhalten,deren Geburtstag vor dem 01.08.1956 liegt. Mit dieser Information kann aber nur schlecht weitergearbeitet werden, da wir bis jetzt nur GepaeckIds haben. Aus diesem Grund kommt wird ein "ClimbingIndex" auf dem Attribut Geburtsdatum verwendet(siehe Tabelle 9.1) und auf diesem wird dann die Selektion ausgeführt. Als Ergebnis werden folgende GepaeckIds im sicheren Bereich vorgehalten:
G07, G18, G19, G20, G25.
Die nun vorhandenen IDs können mittels der Schnittmenge verringert werden um den Aufwand für den nachfolgenden Join \textbf{TODO: darf man hier Join erwähnen oder sollte es SJoin heißen} zu verringern.
Als Ergebnis bekommt man: G18, G19, G20.





\textbf{TODO: bessere Skalierung für das Bild wählen}%
\begin{figure}[htbp]%
  \centering%
  \frame{\includegraphics[width=1\linewidth]{img/Pre1}}%
  \caption{Teilergebnis 1}%
  \label{fig: Teilergebnis 1}%
\end{figure}%



Im Nachfolgenden müssen alle "Statements" in der "WHERE-Clause" erfüllt werden. Dies geschieht unter zu Hilfenahme von Semi-Joins und diese werden wiederum durch "Subtree Key Tables"(SKT) unterstützt. Die "Where Clause", die wir berechnen wollen ist folgende:  G.Reisender=R.ReisenderID . Im SKT für Gepaeck (Tabelle 8.2) werden nun die ReisendenIds zu den entsprechenden GepaeckIds herausgesucht, dies geschieht mittels SJoin.\textbf{TODO: kann man das so schreiben ??}
Da wir nun ReisendeIds haben kann die nächste Bedingung in Angriff genommen werden: B.Reisender=R.ReisenderID. Hierfür werden ReisendeIds auf Basis der BuchungsIds benötigt. Die Selektion mittels GepäckIds entfällt da diese keine direkte Verbindung zu den Buchungen haben. Da wir schon die Piloten vorhin als selektives Mittel verwendet haben tun wir dies diesmal auch wieder mittels eines "Climbing Indexes" auf den BuchungsIds. Da der "Climbing Index" als Ergebnis eine Liste von Listen liefert, wir für den SKT aber nur eine Liste verwenden können müssen wir die erhaltenen Listen in der Liste mittels Vereinigung zusammenführen. Als Ergebnis würden wir folgendes Erhalten: B08, B11, B18, B19, B20, B21.


\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Pre2.pdf}
  \caption{Teilergebnis 2}
  \label{fig: Teilergebnis 2}
\end{figure}

Die so erhaltenen BuchungsIds werden analog zu den GepäckIds im vorherigen Schritt benutzt um ReisendeIds. Um beide Bedingungen zu erfüllen muss nun noch der Durchschnitt der beiden ReisendenIds erzielt werden, damit wären beide Bedingungen erfüllt. Nit diesem Ergebnis kann dann weiter gearbeitet werden.


\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Pre3.pdf}
  \caption{Teilergebnis 3}
  \label{fig: Teilergebnis 3}
\end{figure}

Auf dieser entstandenen Datenbasis wird nun ein Bloomfilter gebaut, der für die noch nicht angewandte Selektion verwendet wird. 
Die fehlende Selektion ist diese: R.Geschlecht='M'. Die Selektion wird erst jetzt angewandt, da Sie sonst vorher in den beiden Joins die zu bearbeitenden Datenmengen erhöht hätte. Durch den späteren Einsatz können die Datenmengen geringer gehalten werden udn der Rechenaufwand ist somit geringer.

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Pre4.pdf}
  \caption{Teilergebnis 4}
  \label{fig: Teilergebnis 4}
\end{figure}

Als Abschluss müssen nur noch die entsprechenden Projektionen angewendet werden, dies geschieht mittels eines MJoins. Dieser benötigt aber nochmals alle ReisendenIds mit der Eigenschaft das das Geschlecht männlich ist. Bei dieser Anfrage werden aber nicht nur die ReisendenIds benötigt, sondern auch die Attribute für Vorname und Name.
Als Ergebnis kann dann folgendes ausgegeben werden:  R04,Doru,Davidovici,Romänisch 

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Pre5.pdf}
  \caption{Teilergebnis 5}
  \label{fig: Teilergebnis 5}
\end{figure}
 

Fügt man die einzelnen Schritte zusammen entsteht folgender Ausführungsplan für das Prefiltering:
\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Pre-Filtering.pdf}
  \caption{Gesamtplan}
  \label{fig: Gesamtplan}
\end{figure}
Die einzelnen "Methoden" die zur Berechnung verwendet wurden kann man sich unter der Rubrik Query Excecution Plans noch einmal genauer ansehen.
Auf den ersten Blick scheint die Lösung des Prefiltering optimal zu sein, da man schon im Vorfeld viele Daten \textbf{TODO: ist Daten das Richtige Wort ???} aus der Berechnung der Joins herausnehmen kann und somit den Aufwand verringert. 
Das Problem an dieser Strategie ist allerdings, dass bei zu geringer Selektivität der "Selektionen" zu wenig Daten im Vorfeld aussortieren und somit ein großer Vorteil des Prefilterings verschwindet. Eine andere Alternative die dem eben angesprochenen Effekt nicht so stark unterliegt ist das Postfiltering. 


\subsection{Postfiltering}

Beim Postfiltering werden zuerst alle Selektionen ausgeführt und per Join zusammengefasst, die auf den sicheren Bereich zugreifen. Erst danach werden mittels "Fuzzy filtering"\footnote{GhostDB: Hiding Data from Prying Eyes(Technology) Vortrag } die Selektionen des unsicheren Bereiches hinzugefügt.


Für unser Beispiel heißt dies, dass zuerst die Selektion auf dem Geburtsdatum des Piloten ausgeführt wird. Da wir mit der PilotId aber nicht ohne weiteres weiterarbeiten können verwenden wir hierfür den "Climbing Index" auf der GepaeckID und führen auf diesem Ergebnis eine Vereinigung aus, da wir nur eine Liste von GepaeckIds gebrauchen können.
 

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Post1.pdf}
  \caption{Teilergebnis 1}
  \label{fig: Teilergebnis 1}
\end{figure}

Diese Selektion ist in unserem Beispiel die Einzige die auf den unsicheren Bereich zugreift, nach dem Verfahren des Postfilterings werden diese Ids nun für einen Join benutzt. Als Ergebnis brauchen wir wiederum ReisendeIds, da diese für die spätere Projektion notwendig sind. Um diese Ids zu erhalten bedienen wir uns wieder dem "Subtree Key Table" und Filtern uns somit alle ReisendeIds heraus. Bei den Selektionen aus dem unsicheren Berich erhalten wir aber GepaeckIds, daher gibt uns der Join auf unsere Anforderung hin eine Menge von Tupeln aus GepaeckId und dazu passender ReisenderId heraus.


\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Post2.pdf}
  \caption{Teilergebnis 2}
  \label{fig: Teilergebnis 2}
\end{figure}

Im nächsten Schritt kann nun die Selektion auf dem Gepäck, welches ein Gewicht größer als 20 Kilogramm hat geschehen. Wie oben schon erwähnt wird hierfür das "Fuzzy Filtering" benutzt. In unserem Fall ist es so definiert, das ein Bloomfilter über eine bestimmte Menge von Daten generiert wird und dieser Filter dann auf eine andere Menge angewendet wird. Man könnte diesesn Filter evtl. auf das Ergebnis des Joins beziehen, da diese Ergebnisse aber im sicheren Bereich sind würden wir hier nur unnötig Ressourcen verbruachen. Eine bessere Lösung ist es den Bloomfilter auf der Selektion der Daten des unsicheren Bereiches zu generieren, da hier mehr Resosurcen zur Verfügung stehen.
Es wird also ein Bloomfilter auf dem Ergebnis von G.Gewicht>20 gebildet und auf folgende Daten des Joins angewendet:
{  	G07,R11 ;	G18,R07 ;	G19,R04 ;	G20,R04 ;	G22,R02 ; 	G23,R01 }.
Hierbei ist zu beachten das nur die GepaeckIds des Ergebnisses betrachtet werden, da nur diese im Bloomfilter vorkommen.
Auf der Ausgabe des Bloomfilters wird nachfolgend noch eine Projektion auf die ReisendeIds vorgenommen, da wir die Tupel aus GepaeckId und ReisendeId nicht mehr benötigen für die nächsten Schritte. Das Ergebnis sind folgende ReisendeIds: {R07, R04, R04, R02, R01 }

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Post3.pdf}
  \caption{Teilergebnis 3}
  \label{fig: Teilergebnis 3}
\end{figure}

                           
Als nächster logischer Schritt würde die Selektion auf dem Geschlecht folgen,da aber durch die "Where-Clause" B.Reisender=R.ReisenderID ebenfalls ReisendeIds entstehen, die verglichen werden müssen wird dieser Schritt vorgezogen, da andernfalls die Selektion ein zweites Mal erfolgen müsste. Diesen Mehraufwand wollen wir uns ersparen. Um die entsprechende "Where-Clause" zu erfüllen benötigen wir BuchungsIds, die wir dann in entsprechende ReisendeIds umwandeln können. Hier verwenden wir das gleiche Schema wie im Prefiltering. Mittels der Selektion auf dem Geburtsdatum des Piloten erhalten wir durch den "Climbing Index" eine Liste von Listen mit BuchungsIds, diese muss durch eine Vereinigung zu einer Liste zusammengeführt werden.
Im folgenden wird eine SemiJoin angewendet, der unter zuhilfenahme eines "Subtree Key Tables" uns die entsprechenden ReisendeIds ausgibt, die wir dann weiterverwenden. Als Ergebnis werden folgende Ids geliefert: {R07, R03, R13, R05, R04, R11}

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Post4.pdf}
  \caption{Teilergebnis 4}
  \label{fig: Teilergebnis 4}
\end{figure}


Die beiden Mengen von ReisendeIds werden nun mittels Durchschnitt miteinander vereint. Dieses Ergebnis wird nachfolgend durch einen Bloomfilter geschickt, der durch die Selektion des Geschlechtes auf die Reisenden(Reisender.Geschlecht='M') im unsicheren Bereich erstellt wurde. Die nun erhaltenen Ids werden wie im Prefiltering mittels MJoin zusammengefügt und als ERgebnis erhält man: { R04,Doru,Davidovici,Romänisch }.


\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Post5.pdf}
  \caption{Teilergebnis 5}
  \label{fig: Teilergebnis 5}
\end{figure}


Fügt man nun wie schon oben alle Teile zusammen erhält man den kompletten Ablaufplan für unsere Anfrage.

\textbf{TODO: bessere Skalierung für das Bild wählen}
\begin{figure}[htbp]
  \centering
  \includegraphics[width=1\textwidth]{img/Post-Filtering.pdf}
  \caption{Post-Filtering QEP}
  \label{Post-Filtering QEP}
\end{figure}


