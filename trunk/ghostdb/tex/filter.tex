\chapter{Warum Filter ?}

Das System ``GhostDB'' hat das Problem, dass alle Berechnungen die Bezug auf die unsichtbaren Daten auf dem ``SmartUSB''-Stick nehmen in diesem berechnet werden müssen. Da der Speicher für die Ausführung auf diesem Gerät aber begrenzt ist, entsteht hier ein Ressourcenproblem, da alle Daten in den Speicher geladen werden müssen und weiterhin in diesem auch Platz für das Ergebnis vorhanden sein muss. Die Autoren der Paper haben daher eine Möglichkeit gesucht die Menge an Informationen, die in den Speicher geladen werden müssen, um eine Antwort auf die gestellte Anfrage zu erhalten, zu verringern. Das Ergebnis waren die Post-, Pre- und Crossfilter. In dieser Arbeit werden wir nur auf die ersten beiden eingehen.

\section{Prefiltering}

Die Idee beim Prefiltering ist, dass alle Selektionen zuerst ausgeführt werden um die gesamte Datenmenge die bei Joins und Mergeoperationen verwendet werden so gering wie möglich zu halten. Weiterhin wird versucht so viele Selektionen wie möglich auf dem unsicheren Bereich auszuführen, da die Ressourcen hier nicht so beschränkt sind, wie im sicheren Bereich. Selektionen auf Daten die den sicheren Teil der ``GhostDB'' betreffen können allerdings auch nur in diesem ausgeführt werden. Für die Selektionen werden nach Möglichkeit ``Climbing'' Indizes verwendet. Die danach folgenden Joins werden dann im sicheren Bereich ausgeführt, hierbei wird dann meist ein ``Subtree Key Table'' verwendet.

\section{Postfiltering}

Beim Postfiltering wird ein anderes Verfahren verwendet. Es wird hier zuerst der Join auf dem sicheren Teil der ``GhostDB'' ausgeführt. Im folgenden werden die möglichen Selektionen des unsicheren Bereiches zu den erzeugten Ergebnissen hinzugefügt. Dies geschieht entweder durch das Erzeugen eines Blommfilters aus diesen Daten, der dann für die Filterung der bisherigen Ergebnisse benutzt wird oder genau umgekehrt. Im umgedrehten Fall wird der Bloomfilter aus den vorhandenen Resultaten gebildet und die Daten der Selektion werden mit diesem gefiltert. Die übrig gebliebenen Daten werden dann weiterverabeitet. \textbf{TODO: hier könnte noch mehr kommen}

Cross-Filtering kann teilweise bessere Ergebnisse erzielen. Es wird versucht die Kardinalität von Zwischenergebnissen des unsicheren Geräts so klein wie möglich zu halten, indem ``Filter'' oder ``Merge''-Operationen mit sicheren Daten so früh wie möglich durchgeführt werden.

Im Nachfolgenden wollen wir anhand eines Beispieles die Funktionsweise der Filter nachvollziehbar machen.
